"use strict";(self.webpackChunkguide=self.webpackChunkguide||[]).push([[188],{3441:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>g,frontMatter:()=>c,metadata:()=>l,toc:()=>u});var i=n(4848),s=n(8453);const o=n.p+"assets/images/breakeven-c520ae6425e43f3751491931caa4cb36.jpg",a=n.p+"assets/images/shiftLeft-df36f8a669c3668d7e52f87fc282be70.png",r=n.p+"assets/images/gTest-be8d872d883874e79a59740edb8c09df.jpg",c={sidebar_position:2},d="Benefits of Introducing Unit Tests",l={id:"intro/benefits",title:"Benefits of Introducing Unit Tests",description:"This chapter explains the general benefits of introducing unit tests. If you are already familiar with unit tests, you don\u2019t need to read this section. If you are eager to know how to introduce unit tests into embedded software development, please proceed to the next chapter.",source:"@site/docs/intro/benefits.md",sourceDirName:"intro",slug:"/intro/benefits",permalink:"/embeded-testing-guide/docs/intro/benefits",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro/benefits.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"State of Embedded Software Development I Encountered",permalink:"/embeded-testing-guide/docs/intro/introduction"},next:{title:"Unit Test Frameworks",permalink:"/embeded-testing-guide/docs/intro/tools"}},h={},u=[{value:"Benefits",id:"benefits",level:2},{value:"Reducing Workload",id:"reducing-workload",level:3},{value:"Preventing Regressions",id:"preventing-regressions",level:3},{value:"Pinpointing Bug Locations",id:"pinpointing-bug-locations",level:3},{value:"Developing with Confidence",id:"developing-with-confidence",level:3},{value:"Shift Left",id:"shift-left",level:3},{value:"Living Documentation",id:"living-documentation",level:3},{value:"Testing Edge Cases",id:"testing-edge-cases",level:3},{value:"Caution",id:"caution",level:2}];function f(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"benefits-of-introducing-unit-tests",children:"Benefits of Introducing Unit Tests"})}),"\n",(0,i.jsx)(t.p,{children:"This chapter explains the general benefits of introducing unit tests. If you are already familiar with unit tests, you don\u2019t need to read this section. If you are eager to know how to introduce unit tests into embedded software development, please proceed to the next chapter."}),"\n",(0,i.jsx)(t.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(t.h3,{id:"reducing-workload",children:"Reducing Workload"}),"\n",(0,i.jsx)(t.p,{children:"Some people may think that the workload increases because you have to write code for testing in addition to the product code. Certainly, in the early stages of development, progress may seem faster if tests are not written. However, once a project reaches a certain scale, introducing unit tests results in lower total costs."}),"\n",(0,i.jsx)("img",{src:o,alt:"Break-even Point",width:"700"}),"\n",(0,i.jsx)(t.p,{children:"Unit tests, which have short execution times and provide immediate feedback, are less affected by specification changes compared to integration or manual (E2E) tests. Even for small projects, unit tests can be worthwhile. Unless you\u2019re working with disposable scripts, the workload required for testing will pay off."}),"\n",(0,i.jsx)(t.h3,{id:"preventing-regressions",children:"Preventing Regressions"}),"\n",(0,i.jsx)(t.p,{children:"It is difficult to consider all the settings, device versions, and combinations when adding new features, making manual testing costly. Eventually, team might start skipping tests that don\u2019t seem related to the latest changes."}),"\n",(0,i.jsx)(t.p,{children:"With automated tests, the execution cost is nearly zero. By running tests for every commit or pull request, you can quickly verify that no regressions have been introduced."}),"\n",(0,i.jsx)(t.h3,{id:"pinpointing-bug-locations",children:"Pinpointing Bug Locations"}),"\n",(0,i.jsx)(t.p,{children:"When a unit test fails, the testing framework shows where it failed, what the expected value was, and what the actual value was. In contrast, with manual testing, it takes time to recreate a bug and then identify where the problem lies."}),"\n",(0,i.jsx)("img",{src:r,alt:"gtest",width:"700"}),"\n",(0,i.jsx)(t.h3,{id:"developing-with-confidence",children:"Developing with Confidence"}),"\n",(0,i.jsx)(t.p,{children:"If you add new code and existing tests fail, then there is likely an issue in the new code you\u2019ve written. If all tests pass, you can proceed with confidence."}),"\n",(0,i.jsx)(t.h3,{id:"shift-left",children:"Shift Left"}),"\n",(0,i.jsx)(t.p,{children:"With only manual tests, you can\u2019t verify software behavior until the physical product is complete. If the hardware is delayed or devices are limited, development can stall. With unit tests, you can test component-level behavior using just a PC."}),"\n",(0,i.jsx)(t.p,{children:"This allows you to shift development efforts to earlier stages in the process. Since the cost of fixing issues increases as development progresses, shifting left helps reduce overall costs."}),"\n",(0,i.jsx)("img",{src:a,alt:"Shift Left",width:"700"}),"\n",(0,i.jsx)(t.h3,{id:"living-documentation",children:"Living Documentation"}),"\n",(0,i.jsxs)(t.p,{children:["Google Test\u2019s ",(0,i.jsx)(t.code,{children:"TEST"})," macro accepts arguments for the test case name, allowing you to describe the behavior of the code being tested. ",(0,i.jsx)(t.code,{children:"TEST(TestSuiteName, TestCaseName)"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"// highlight-next-line\nTEST(freeCount, CanCalculateElapsedTimeCorrectlyEvenWithOverflow) {\n  uint32_t startCount = 0xffffffff;\n  uint32_t currentCount = 0x9;\n  EXPECT_EQ(10, CalcElapsedFreeCount(startCount, currentCount));\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Using Doxygen (the C language version of Javadoc) to describe functions is fine, but there is no guarantee that the descriptions will match the implementation. When there are many changes to a function\u2019s specifications or modifications, there is always a chance that someone might forget to update the descriptions. If you have unit tests in place, and there are changes in the product code, even if you forget to update the test code, the tests will fail, alerting you to the issue."}),"\n",(0,i.jsx)(t.h3,{id:"testing-edge-cases",children:"Testing Edge Cases"}),"\n",(0,i.jsx)(t.p,{children:"Unit tests allow you to verify behavior in scenarios that are difficult to test manually, such as overflows, leap years, or when an SD card is full."}),"\n",(0,i.jsx)(t.h2,{id:"caution",children:"Caution"}),"\n",(0,i.jsx)(t.p,{children:"Once tests are introduced, you\u2019ll need to manage both the product code and the test code. If there are changes to the specifications, you\u2019ll need to update not just the product code but the test code as well."}),"\n",(0,i.jsx)(t.p,{children:'Some might say, "See, unit testing is pointless and won\u2019t stick" but I don\u2019t believe that unit testing is ineffective. Rather, I think it\'s more about a lack of the necessary skills to make use of it. Creating software that is testable and less susceptible to specification changes requires skill.'})]})}function g(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);