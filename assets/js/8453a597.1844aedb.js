"use strict";(self.webpackChunkguide=self.webpackChunkguide||[]).push([[161],{3024:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>u,toc:()=>d});var i=n(4848),s=n(8453);const r={sidebar_position:1},o="Unit Testing Methods",u={id:"guide/pattern",title:"Unit Testing Methods",description:"In general, test code checks expected values using the following three patterns:",source:"@site/docs/guide/pattern.md",sourceDirName:"guide",slug:"/guide/pattern",permalink:"/embeded-testing-guide/docs/guide/pattern",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/pattern.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Guide",permalink:"/embeded-testing-guide/docs/category/guide"},next:{title:"Dependencies",permalink:"/embeded-testing-guide/docs/guide/dependencies"}},c={},d=[{value:"Output-based Testing",id:"output-based-testing",level:2},{value:"State-based Testing",id:"state-based-testing",level:2},{value:"Communication Testing",id:"communication-testing",level:2}];function a(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"unit-testing-methods",children:"Unit Testing Methods"})}),"\n",(0,i.jsx)(t.p,{children:"In general, test code checks expected values using the following three patterns:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Output-based testing"}),"\n",(0,i.jsx)(t.li,{children:"State-based testing"}),"\n",(0,i.jsx)(t.li,{children:"Communication testing"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"output-based-testing",children:"Output-based Testing"}),"\n",(0,i.jsx)(t.p,{children:"This method verifies whether the value returned by the code under test matches the expected value. It is the simplest and easiest to write but assumes that the code under test has no side effects."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="Output-based Testing"',children:"TEST(calcElapsedFreeCount, CanCalculateElapsedTimeCorrectlyEvenWithOverflow) {\n    uint32_t startCount = 0xffffffff;\n    uint32_t currentCount = 0x9;\n    EXPECT_EQ(10, TrpSensing_calcElapsedFreeCount(startCount, currentCount));\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"state-based-testing",children:"State-based Testing"}),"\n",(0,i.jsx)(t.p,{children:"This method checks the state (member variables) after the code under test is executed. It is slightly more complex compared to output-based testing. In C language, it looks like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="\u30d7\u30ed\u30c0\u30af\u30c8\u30b3\u30fc\u30c9 couter.h"',children:"#ifndef COUNTER_H\n#define COUNTER_H\n\ntypedef struct {\n    int value;\n} Counter;\n\nvoid initCounter(Counter* counter);\nvoid incrementCounter(Counter* counter);\nint getCounterValue(Counter* counter);\n\n#endif // COUNTER_H\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="production code couter.c"',children:'#include "counter.h"\n\nvoid initCounter(Counter* counter) {\n    counter->value = 0;\n}\n\nvoid incrementCounter(Counter* counter) {\n    counter->value++;\n}\n\nint getCounterValue(Counter* counter) {\n    return counter->value;\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="test code testCounter.c"',children:"TEST(CounterTest, CounterInitialValueIsZero) {\n    Counter counter;\n    initCounter(&counter);\n    EXPECT_EQ(getCounterValue(&counter), 0);\n}\n\nTEST(CounterTest, CounterValueIncrements) {\n    Counter counter;\n    initCounter(&counter);\n    incrementCounter(&counter);\n    EXPECT_EQ(getCounterValue(&counter), 1);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"In object-oriented programming, this would be like checking the value of a class's member variables later."}),"\n",(0,i.jsx)(t.h2,{id:"communication-testing",children:"Communication Testing"}),"\n",(0,i.jsxs)(t.p,{children:["This method verifies that the code under test correctly calls other functions or APIs. Since you need to use mocks or spies, the implementation cost is higher. Details will be explained ",(0,i.jsx)(t.a,{href:"/embeded-testing-guide/docs/guide/methods/mock",children:"later"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>u});var i=n(6540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function u(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);