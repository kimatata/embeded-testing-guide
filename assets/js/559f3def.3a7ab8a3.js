"use strict";(self.webpackChunkguide=self.webpackChunkguide||[]).push([[188],{2502:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>p,frontMatter:()=>d,metadata:()=>l,toc:()=>u});var i=n(4848),s=n(8453);const o=n.p+"assets/images/breakeven-c520ae6425e43f3751491931caa4cb36.jpg",a=n.p+"assets/images/shift-left-4e958729690fa4214f7f6686dab061ae.png",r=n.p+"assets/images/gTest-8d6c922060eaa7128d12091d7ff3f045.png",d={sidebar_position:2},c="Benefits of Introducing Unit Tests",l={id:"intro/benefits",title:"Benefits of Introducing Unit Tests",description:"This chapter explains the general benefits of introducing unit tests. If you are already familiar with unit tests, you don\u2019t need to read this section. If you are eager to know how to introduce unit tests into embedded software development, please proceed to the next chapter.",source:"@site/docs/intro/benefits.md",sourceDirName:"intro",slug:"/intro/benefits",permalink:"/embeded-testing-guide/docs/intro/benefits",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/intro/benefits.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"State of Embedded Software Development I Encountered",permalink:"/embeded-testing-guide/docs/intro/introduction"},next:{title:"Unit Testing Frameworks",permalink:"/embeded-testing-guide/docs/intro/tools"}},h={},u=[{value:"Benefits",id:"benefits",level:2},{value:"Reducing Workload",id:"reducing-workload",level:3},{value:"Preventing Regressions",id:"preventing-regressions",level:3},{value:"Pinpointing Bug Locations",id:"pinpointing-bug-locations",level:3},{value:"Developing with Confidence",id:"developing-with-confidence",level:3},{value:"Shift Left",id:"shift-left",level:3},{value:"Living Documentation",id:"living-documentation",level:3},{value:"Testing Edge Cases",id:"testing-edge-cases",level:3},{value:"Caution",id:"caution",level:2}];function f(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"benefits-of-introducing-unit-tests",children:"Benefits of Introducing Unit Tests"})}),"\n",(0,i.jsx)(t.p,{children:"This chapter explains the general benefits of introducing unit tests. If you are already familiar with unit tests, you don\u2019t need to read this section. If you are eager to know how to introduce unit tests into embedded software development, please proceed to the next chapter."}),"\n",(0,i.jsx)(t.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(t.h3,{id:"reducing-workload",children:"Reducing Workload"}),"\n",(0,i.jsx)(t.p,{children:"Some people may think that the workload increases because you have to write test code in addition to the product code. Certainly, in the early stages of development, progress may seem faster if tests are not written. However, once a project reaches a certain scale, introducing unit tests results in lower total costs."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)("img",{src:o,alt:"Break-even Point",width:"700"})," ",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,i.jsx)(t.p,{children:"Unit tests, which have short execution times and provide immediate feedback, are less affected by specification changes compared to integration or manual (E2E) tests. Even for small projects, unit tests can be worthwhile. Unless you\u2019re working with disposable scripts, the workload required for testing will pay off."}),"\n",(0,i.jsx)(t.h3,{id:"preventing-regressions",children:"Preventing Regressions"}),"\n",(0,i.jsx)(t.p,{children:"It is difficult to consider all the settings, device versions, and combinations when adding new features, making manual testing costly. Eventually, team might start skipping tests that don\u2019t seem related to the latest changes."}),"\n",(0,i.jsx)(t.p,{children:"With automated tests, the execution cost is nearly zero. By running tests for every commit or every pull request, you can quickly verify that no regressions have been introduced."}),"\n",(0,i.jsx)(t.h3,{id:"pinpointing-bug-locations",children:"Pinpointing Bug Locations"}),"\n",(0,i.jsx)(t.p,{children:"When a unit test fails, the testing framework shows where it failed, what the expected value was, and what the actual value was. In contrast, with manual testing, it takes time to recreate a bug and then identify where the problem lies."}),"\n",(0,i.jsx)("img",{src:r,alt:"gtest",width:"700"}),"\n",(0,i.jsx)(t.h3,{id:"developing-with-confidence",children:"Developing with Confidence"}),"\n",(0,i.jsx)(t.p,{children:"If you add new code and existing tests fail, then there is likely an issue in the new code you\u2019ve written. If all tests pass, you can proceed with confidence."}),"\n",(0,i.jsx)(t.h3,{id:"shift-left",children:"Shift Left"}),"\n",(0,i.jsx)(t.p,{children:"With only manual tests, you can\u2019t verify software behavior until the physical device is complete. If the hardware is delayed or devices are limited, development can stall. With unit tests, you can test component-level behavior on PC."}),"\n",(0,i.jsx)(t.p,{children:"This allows you to shift development efforts to earlier stages in the process. Since the cost of fixing issues increases as development progresses, shifting left helps reduce overall costs."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)("img",{src:a,alt:"Shift Left",width:"700"})," ",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})]}),"\n",(0,i.jsx)(t.h3,{id:"living-documentation",children:"Living Documentation"}),"\n",(0,i.jsxs)(t.p,{children:["Google Test\u2019s ",(0,i.jsx)(t.code,{children:"TEST"})," macro accepts arguments for the test case name, allowing you to describe the behavior of the code being tested. ",(0,i.jsx)(t.code,{children:"TEST(TestSuiteName, TestCaseName)"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"// highlight-next-line\nTEST(Counter, CanCalculateElapsedTimeCorrectlyEvenWithOverflow) {\n    uint32_t startValue = 0xffffffff;\n    uint32_t currentValue = 0x9;\n    EXPECT_EQ(10, Counter_GetElapsedCount(startValue, currentValue));\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Using Doxygen (the C language version of Javadoc) to describe functions is fine, but there is no guarantee that the descriptions will match the implementation. When there are many changes to a function\u2019s specifications or modifications, there is always a chance that someone might forget to update the descriptions. If you have unit tests in place, and there are changes in the product code, even if you forget to update the test code, the tests will fail, alerting you to the issue."}),"\n",(0,i.jsx)(t.h3,{id:"testing-edge-cases",children:"Testing Edge Cases"}),"\n",(0,i.jsx)(t.p,{children:"Unit tests allow you to verify behavior in scenarios that are difficult to test manually, such as overflows, leap years, or when an SD card is full."}),"\n",(0,i.jsx)(t.h2,{id:"caution",children:"Caution"}),"\n",(0,i.jsx)(t.p,{children:"After introducing tests, you\u2019ll need to manage both the product code and the test code. If there are changes to the specifications, you\u2019ll need to update not just the product code but the test code as well."}),"\n",(0,i.jsx)(t.p,{children:'Some might say, "See, unit testing is pointless and won\u2019t stick around." But I don\u2019t think that unit testing is ineffective. In fact, many software development books dedicate an entire chapter or more to unit testing, highlighting how essential it is in the field. To claim that unit testing is useless after seeing such emphasis might take a bit of boldness, wouldn\u2019t you agree?'}),"\n",(0,i.jsx)(t.p,{children:"Rather, the reason unit testing doesn\u2019t stick is often because we haven\u2019t yet developed the skills needed to design and maintain both product and test code effectively. Creating software that is not only functional but also testable and resilient to specification changes requires a higher level of skill compared to simply getting it to work."}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1",children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://egesoftware.blogspot.com/2013/03/mitos-de-los-tests-unitarios.html",children:"https://egesoftware.blogspot.com/2013/03/mitos-de-los-tests-unitarios.html"})," ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{id:"user-content-fn-2",children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://devopedia.org/shift-left",children:"https://devopedia.org/shift-left"})," ",(0,i.jsx)(t.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);