"use strict";(self.webpackChunkguide=self.webpackChunkguide||[]).push([[414],{3698:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var i=n(4848),s=n(8453);const o={sidebar_position:2},r="Extracting Logic",d={id:"guide/methods/extract",title:"Extracting Logic",description:"Existing product code that hasn\u2019t introduced tests is likely not designed with testing in mind, meaning output-based tests will be challenging. While it\u2019s possible to write tests using mocks without modifying the product code, test code using mocks tends to become complex.",source:"@site/docs/guide/methods/extract.md",sourceDirName:"guide/methods",slug:"/guide/methods/extract",permalink:"/embeded-testing-guide/docs/guide/methods/extract",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/methods/extract.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Dependency Separation",permalink:"/embeded-testing-guide/docs/guide/methods/patterns"},next:{title:"\u30b3\u30f3\u30d1\u30a4\u30eb\u30b9\u30a4\u30c3\u30c1\u306b\u3088\u308b\u7f6e\u304d\u63db\u3048",permalink:"/embeded-testing-guide/docs/guide/methods/compile-switch"}},a={},c=[{value:"Refactoring",id:"refactoring",level:2},{value:"When Testing is Difficult",id:"when-testing-is-difficult",level:3},{value:"When Testing Becomes Possible",id:"when-testing-becomes-possible",level:3}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"extracting-logic",children:"Extracting Logic"})}),"\n",(0,i.jsx)(t.p,{children:"Existing product code that hasn\u2019t introduced tests is likely not designed with testing in mind, meaning output-based tests will be challenging. While it\u2019s possible to write tests using mocks without modifying the product code, test code using mocks tends to become complex."}),"\n",(0,i.jsx)(t.p,{children:"Instead of forcibly using mocks, consider refactoring the product code to enable output-based testing."}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"Testable code = loosely coupled, easy-to-understand code"})}),"\n",(0,i.jsx)(t.h2,{id:"refactoring",children:"Refactoring"}),"\n",(0,i.jsx)(t.p,{children:'Embedded software code is often composed of both logic and hardware commands. Ideally, logic and hardware commands are well-separated, but in situations where deadlines are tight and the software must "just work," the code is likely to have these aspects mixed together.'}),"\n",(0,i.jsx)(t.p,{children:"To make output-based testing possible, refactor this tightly coupled code and extract the logic. The extracted code won\u2019t depend on hardware, making it easier to build and test."}),"\n",(0,i.jsx)(t.h3,{id:"when-testing-is-difficult",children:"When Testing is Difficult"}),"\n",(0,i.jsx)(t.p,{children:"Let\u2019s consider an embedded product that stores an array of ST_LED_INFO structures indicating the status of each LED in ROM."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",children:"typedef struct {\n    uint8_t isUsed : 1;\n    uint8_t brightness : 7;\n    uint8_t ledNo;\n} ST_LED_INFO;\n"})}),"\n",(0,i.jsx)(t.p,{children:"There is a function that reads this data into RAM and returns the sorted result based on certain conditions."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="ledData.c(Product Code)"',children:"int8_t LedData_GetStoredInfoList(ST_LED_INFO* pList) {\n    // read data from ROM to RAM\n    nvrReadData(nvrReader, NVR_LED_INFO, 0, (LED_INFO_NUM * sizeof(ST_LED_INFO)), (void*)&ledInfoRecords[0]);\n\n    // sort\n    qsort(ledInfoRecords, num, sizeof(ST_LED_INFO), compare);\n\n    return OK;\n}\n\nstatic int compare(const void* a, const void* b) {\n    ST_LED_INFO* infoA = (ST_LED_INFO*)a;\n    ST_LED_INFO* infoB = (ST_LED_INFO*)b;\n\n    if (infoA->ledNo != infoB->ledNo) {\n        return infoA->ledNo - infoB->ledNo;\n    } else {\n        return infoA->brightness - infoB->brightness;\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"nvrReadData()"})," function is platform-specific, reading data from ROM. While this works on the embedded board, it cannot be built or run in the test environment."]}),"\n",(0,i.jsx)(t.h3,{id:"when-testing-becomes-possible",children:"When Testing Becomes Possible"}),"\n",(0,i.jsx)(t.p,{children:"In the previous example, platform-specific functions prevented building and running the code in a test environment. To make the logic more testable, especially the sorting logic that is complex and prone to bugs, we can extract this part into a separate file."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="ledData.c(separate sort part to other file)"',children:"int8_t LedData_GetStoredInfoList(ST_LED_INFO* pList) {\n    // read data from ROM to RAM\n    nvrReadData(nvrReader, NVR_LED_INFO, 0, (LED_INFO_NUM * sizeof(ST_LED_INFO)), (void*)&ledInfoRecords[0]);\n\n    // sort\n    LedCtrlImpl_Sort(pList, count);\n\n    return OK;\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="Refactored Product code(pure function) ledDataImpl.c"',children:"/*\n * Sort an array of ST_LED_INFO\n */\nvoid LedCtrlImpl_Sort(ST_LED_INFO* pList, size_t num) {\n    qsort(pList, num, sizeof(ST_LED_INFO), compare);\n}\n\n/*\n * Comparison function for sorting an array of ST_LED_INFO\n *\n * Sort in ascending order by brightness.\n * If brightness is the same, sort in ascending order by ledNo.\n */\nstatic int compare(const void* a, const void* b) {\n    ST_LED_INFO* infoA = (ST_LED_INFO*)a;\n    ST_LED_INFO* infoB = (ST_LED_INFO*)b;\n\n    if (infoA->brightness != infoB->brightness) {\n        return infoA->brightness - infoB->brightness;\n    } else {\n        return infoA->ledNo - infoB->ledNo;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-c",metastring:'title="Test Code testLedDataImpl.cpp"',children:"TEST(ledCtrlImpl, SortsListInAscendingOrderByBrightness) {\n    ST_LED_INFO ledInfoRecords[3] = {0};\n    ledInfoRecords[0].brightness = 20;\n    ledInfoRecords[1].brightness = 110;\n    ledInfoRecords[2].brightness = 60;\n    LedDataImpl_Sort(ledInfoRecords, 3);\n\n    EXPECT_EQ(20, ledInfoRecords[0].brightness);\n    EXPECT_EQ(60, ledInfoRecords[1].brightness);\n    EXPECT_EQ(110, ledInfoRecords[2].brightness);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now, we are able to test the sorting logic. Although ",(0,i.jsx)(t.code,{children:"ledData.c"})," itself is still not testable, bugs typically arise from complex logic. Therefore, enabling tests for the sorting logic is valuable. Additionally, ",(0,i.jsx)(t.code,{children:"ledData.c"})," is relatively simple and not likely to change often, so the return on investment from writing test code for it may be limited."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);